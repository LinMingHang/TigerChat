# Netty+SpringBoot+FastDFS+MUI实现聊天App详解(三)

本节主要讲解聊天App tigerChat中关于好友申请的发送与接受。

包含以下内容:

​	（1）搜索好友接口

​	（2）发送添加好友申请的接口

​	（3）接受添加好友申请的接口

# 搜索好友接口

定义枚举类型 SearchFriendsStatusEnum，表示添加好友的前置状态

```java
    SUCCESS(0, "OK"),
    USER_NOT_EXIST(1, "无此用户..."),    
    NOT_YOURSELF(2, "不能添加你自己..."),            
    ALREADY_FRIENDS(3, "该用户已经是你的好友...");
```

在service中定义搜索朋友的前置条件判断的方法preconditionSearchFriends。

传入的是用户的Id以及搜索的用户的名称。

【1】首先根据搜索的用户的名称查找是否存在这个用户。

【2】如果搜索的用户不存在，则返回[无此用户]。

【3】如果搜索的用户是你自己，则返回[不能添加自己]。

【4】如果搜索的用户已经是你的好友，则返回[该用户已经是你的好友]。

【5】否则返回成功。

```java
    @Transactional(propagation = Propagation.SUPPORTS)
    @Override
    public Integer preconditionSearchFriends(String myUserId, String friendUsername) {
        //1. 查找要添加的朋友是否存在
        Users user = queryUserInfoByUsername(friendUsername);
        
        // 2. 搜索的用户如果不存在，返回[无此用户]
        if (user == null) {
            return SearchFriendsStatusEnum.USER_NOT_EXIST.status;
        }
        
        // 3. 搜索账号是你自己，返回[不能添加自己]
        if (user.getId().equals(myUserId)) {
            return SearchFriendsStatusEnum.NOT_YOURSELF.status;
        }
        
        // 4. 搜索的朋友已经是你的好友，返回[该用户已经是你的好友]
        Example mfe = new Example(MyFriends.class);
        Criteria mfc = mfe.createCriteria();
        mfc.andEqualTo("myUserId", myUserId);
        mfc.andEqualTo("myFriendUserId", user.getId());
        MyFriends myFriendsRel = myFriendsMapper.selectOneByExample(mfe);
        if (myFriendsRel != null) {
            return SearchFriendsStatusEnum.ALREADY_FRIENDS.status;
        }
        
        //返回成功
        return SearchFriendsStatusEnum.SUCCESS.status;
    }
```

在controller中创建搜索好友接口 searchUser。

传入的是用户的Id，以及要搜索的用户的名字。

【0】首先判断传入的参数是否为空。

【1】通过userService的preconditionSearchFriends方法得到前置条件。

【2】如果搜索前置条件为成功，则向前端返回搜索用户的信息。

【3】否则搜索失败。

```java
    /**
     * @Description: 搜索好友接口, 根据账号做匹配查询而不是模糊查询
     */
    @PostMapping("/search")
    public TigerChatJSONResult searchUser(String myUserId, String friendUsername)
            throws Exception {
        
        // 0. 判断 myUserId friendUsername 不能为空
        if (StringUtils.isBlank(myUserId) 
                || StringUtils.isBlank(friendUsername)) {
            return TigerChatJSONResult.errorMsg("");
        }
        
        // 前置条件 - 1. 搜索的用户如果不存在，返回[无此用户]
        // 前置条件 - 2. 搜索账号是你自己，返回[不能添加自己]
        // 前置条件 - 3. 搜索的朋友已经是你的好友，返回[该用户已经是你的好友]
        //1. 得到前置条件状态
        Integer status = userService.preconditionSearchFriends(myUserId, friendUsername);
        //2. 搜索成功，返回搜索用户的信息
        if (status == SearchFriendsStatusEnum.SUCCESS.status) {
            Users user = userService.queryUserInfoByUsername(friendUsername);
            UsersVO userVO = new UsersVO();
            BeanUtils.copyProperties(user, userVO);
            return TigerChatJSONResult.ok(userVO);
        } else {
        //3. 搜索失败
            String errorMsg = SearchFriendsStatusEnum.getMsgByKey(status);
            return TigerChatJSONResult.errorMsg(errorMsg);
        }
    }
```

# 发送添加好友申请的接口

在service中定义添加好友请求记录，保存到数据库的sendFriendRequest方法。

传入的是添加好友记录的发送方——用户的Id，以及记录的接收方——想要添加的朋友的名称。

【1】首先根据用户名把朋友信息查询出来。

【2】然后查询发送好友请求记录表。

【3】如果不是你的好友，并且好友记录没有添加，则新增好友请求记录。这样可以保证打你发送了两次请求之后，数据库中仍然只记录一次请求的数据。

```java
    @Transactional(propagation = Propagation.REQUIRED)
    @Override
    public void sendFriendRequest(String myUserId, String friendUsername) {
        // 1. 根据用户名把朋友信息查询出来
        Users friend = queryUserInfoByUsername(friendUsername);
        
        // 2. 查询发送好友请求记录表
        Example fre = new Example(FriendsRequest.class);
        Criteria frc = fre.createCriteria();
        frc.andEqualTo("sendUserId", myUserId);
        frc.andEqualTo("acceptUserId", friend.getId());
        FriendsRequest friendRequest = friendsRequestMapper.selectOneByExample(fre);
        if (friendRequest == null) {
            // 3. 如果不是你的好友，并且好友记录没有添加，则新增好友请求记录
            String requestId = sid.nextShort();
            
            FriendsRequest request = new FriendsRequest();
            request.setId(requestId);
            request.setSendUserId(myUserId);
            request.setAcceptUserId(friend.getId());
            request.setRequestDateTime(new Date());
            friendsRequestMapper.insert(request);
        }
    }
```

在controller中创建发送添加好友请求的接口。

传入的是添加好友记录的发送方——用户的Id，以及记录的接收方——想要添加的朋友的名称。

【0】首先判断传入参数不为空。

【1】然后判断前置条件，若为成功则通过userService的sendFriendRequest方法发送好友请求，否则返回失败。

```java
    /**
     * @Description: 发送添加好友的请求
     */
    @PostMapping("/queryFriendRequests")
    public TigerChatJSONResult queryFriendRequests(String userId) {
        
        // 0. 判断不能为空
        if (StringUtils.isBlank(userId)) {
            return TigerChatJSONResult.errorMsg("");
        }
        
        // 1. 查询用户接受到的朋友申请
        return TigerChatJSONResult.ok(userService.queryFriendRequestList(userId));
    }
```

# 接受添加好友申请的接口

在service中定义查询好友请求列表的queryFriendRequestList方法。

```java
    @Transactional(propagation = Propagation.SUPPORTS)
    @Override
    public List<FriendRequestVO> queryFriendRequestList(String acceptUserId) {
        return usersMapperCustom.queryFriendRequestList(acceptUserId);
    }
```

在controller中定义接受添加好友请求的接口queryFriendRequests。

```java
    /**
     * @Description: 发送添加好友的请求
     */
    @PostMapping("/queryFriendRequests")
    public TigerChatJSONResultJSONResult queryFriendRequests(String userId) {
        // 0. 判断不能为空
        if (StringUtils.isBlank(userId)) {
            return TigerChatJSONResultJSONResult.errorMsg("");
        }
        
        // 1. 查询用户接受到的朋友申请
        return TigerChatJSONResultJSONResult.ok(userService.queryFriendRequestList(userId));
    }
```