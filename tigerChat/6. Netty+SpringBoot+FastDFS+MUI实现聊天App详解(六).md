# Netty+SpringBoot+FastDFS+MUI实现聊天App(六)

本章将给聊天App TigerChat加上心跳机制。

## 为什么要实现心跳机制

如果没有特意的设置某些选项或者实现应用层心跳包，TCP**空闲**的时候是**不会发送任何数据包**。也就是说，当一个TCP的socket，客户端与服务端**谁也不发送数据**，会**一直保持着连接**。这其中如果有一方**异常掉线**（例如死机、路由被破坏、防火墙切断连接等），另一端如果没有发送数据，永远也**不可能知道**。这对于一些服务型的程序来说，是灾难性的后果，将会导致服务端socket**资源耗尽**。

举个简单的例子，当我们因为特殊情况打开飞行模式 ，在处理完事件之后再关闭飞行模式，这时候如果再进入应用程序中，我们将以新的channel进入，但是之前的channel还是会保留。

因此，为了保证连接的有效性、及时有效地检测到一方的非正常断开，保证连接的资源被有效的利用，我们就会需要一种**保活的机制**，通常改机制两种处理方式：

1、利用TCP协议层实现的Keepalive；

2、自己在应用层实现心跳包。

## 实现心跳机制

新建一个HeartBeatHandler用于检测channel的心跳。

继承ChannelInboundHandlerAdapter，并重写其userEventTriggered方法。当客户端的所有ChannelHandler中4s内没有write事件，则会触发userEventTriggered方法。

首先我们判断evt是否是IdleStateEvent的实例，IdleStateEvent用于触发用户事件，包含读空闲/写空闲/读写空闲。

对evt进行强制履行转换后，通过state判断其状态，只有当其该channel处于读写空闲的时候才将这个channel关闭。

```java
/**
 * @Description: 用于检测channel的心跳handler 
 *                  继承ChannelInboundHandlerAdapter，从而不需要实现channelRead0方法
 */
public class HeartBeatHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // 判断evt是否是IdleStateEvent（用于触发用户事件，包含 读空闲/写空闲/读写空闲 ）
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent)evt;        // 强制类型转换
            
            if (event.state() == IdleState.READER_IDLE) {
                System.out.println("进入读空闲...");
            } else if (event.state() == IdleState.WRITER_IDLE) {
                System.out.println("进入写空闲...");
            } else if (event.state() == IdleState.ALL_IDLE) {
                
                System.out.println("channel关闭前，users的数量为：" + ChatHandler.users.size());
                
                Channel channel = ctx.channel();
                // 关闭无用的channel，以防资源浪费
                channel.close();
                
                System.out.println("channel关闭后，users的数量为：" + ChatHandler.users.size());
            }
        }
    }
}
```

